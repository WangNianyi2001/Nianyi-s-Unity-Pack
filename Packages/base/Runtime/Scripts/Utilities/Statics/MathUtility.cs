using UnityEngine;
using System.Collections.Generic;

namespace Nianyi.UnityPack
{
	public static class MathUtility
	{
		#region Float
		/// <summary>
		/// Returns the mathematically correct result of <c>a % b</c>.
		/// </summary>
		/// <remarks>
		/// The result always lies in <c>[0, b)</c>, given that <c>b</c> is positive.
		/// For example, <c>Mod(360f, -361f)</c> yields <c>359</c> instead of <c>-1</c>.
		/// </remarks>
		public static float Mod(in this float a, in float b)
		{
			return a - b * Mathf.Floor(a / b);
		}

		public static bool InRange(in this float value, in Vector2 range)
			=> InRange(value, range.x, range.y);
		public static bool InRange(in this float value, in float min, in float max)
		{
			return value >= min && value <= max;
		}

		public static float Clamp(in float value, in Vector2 range)
		{
			return Mathf.Clamp(value, range.x, range.y);
		}
		#endregion

		#region Quaternion
		public static Quaternion Scale(in this Quaternion quat, float t)
		{
			return Quaternion.SlerpUnclamped(Quaternion.identity, quat, t);
		}
		#endregion

		#region Vector
		/// <param name="range">In [0, 90]</param>
		public static Vector3 RotateEulerWithZenithClamped(this Vector3 eulers, in Vector3 delta, float range = 90f)
		{
			range = Mathf.Clamp(range, 0f, 90f);

			var zenith = Mod(eulers.x, 360);
			if(zenith > 180f)
				zenith -= 360f;
			zenith += delta.x;
			zenith = Mathf.Clamp(zenith, -range, range);
			if(zenith < 0f)
				zenith += 360f;

			eulers += delta;
			eulers.x = zenith;

			return eulers;
		}

		public static Vector3 TransformAroundPivot(in Vector3 v, in Matrix4x4 transform, in Vector3 pivot)
		{
			return transform.MultiplyPoint(v - pivot) + pivot;
		}

		public static Vector3 Average(IEnumerable<Vector3> vectors)
		{
			int i = 0;
			Vector3 sum = default;
			foreach(var v in vectors)
			{
				++i;
				sum += v;
			}
			return sum / i;
		}
		#endregion

		#region 2D
		/// <remarks>
		/// Generated by GPT.
		/// </remarks>
		public static bool IsPointinPolygon(Vector2 p, params Vector2[] poly)
		{
			bool inside = false;
			int n = poly.Length;
			for(int i = 0, j = n - 1; i < n; j = i++)
			{
				Vector2 pi = poly[i];
				Vector2 pj = poly[j];

				bool intersect =
					((pi.y > p.y) != (pj.y > p.y)) &&
					(p.x < (pj.x - pi.x) * (p.y - pi.y) / (pj.y - pi.y + 1e-6f) + pi.x);

				if(intersect)
					inside = !inside;
			}
			return inside;
		}

		/// <remarks>
		/// Copied from <c>UnityEditor.HandleUtility.ProjectPointLine</c>.
		/// </remarks>
		public static Vector3 ProjectPointLine(Vector3 point, Vector3 start, Vector3 end)
		{
			Vector3 rhs = point - start;
			Vector3 vector = end - start;
			float magnitude = vector.magnitude;
			Vector3 vector2 = vector;
			if(magnitude > 1E-06f)
			{
				vector2 /= magnitude;
			}

			float value = Vector3.Dot(vector2, rhs);
			value = Mathf.Clamp(value, 0f, magnitude);
			return start + vector2 * value;
		}

		public static float DistanceToLine(Vector3 point, Vector3 start, Vector3 end)
		{
			return ProjectPointLine(point, start, end).magnitude;
		}

		public static float DistanceToPolygon(Vector2 point, Vector2[] poly)
		{
			if(IsPointinPolygon(point, poly))
				return 0f;
			float min = Mathf.Infinity;
			for(int i = 0; i < poly.Length; ++i)
			{
				Vector2 current = poly[i];
				Vector2 next = poly[(i + 1) % poly.Length];
				float distance = DistanceToLine(point, current, next);
				if(distance < min)
					min = distance;
			}
			return min;
		}
		#endregion
	}
}
