using UnityEngine;
using System.Collections.Generic;

namespace Nianyi.UnityPack
{
	public static class MathUtility
	{
		#region Float
		/// <summary>
		/// Returns the mathematically correct result of <c>a % b</c>.
		/// </summary>
		/// <remarks>
		/// The result always lies in <c>[0, b)</c>, given that <c>b</c> is positive.
		/// For example, <c>Mod(360f, -361f)</c> yields <c>359</c> instead of <c>-1</c>.
		/// </remarks>
		public static float Mod(in this float a, in float b)
		{
			return a - b * Mathf.Floor(a / b);
		}

		public static bool InRange(in this float value, in Vector2 range)
			=> InRange(value, range.x, range.y);
		public static bool InRange(in this float value, in float min, in float max)
		{
			return value >= min && value <= max;
		}

		public static float Clamp(in float value, in Vector2 range)
		{
			return Mathf.Clamp(value, range.x, range.y);
		}

		public static IEnumerable<float> Interpolate(uint segmentation = 100, float start = 0f, float end = 1f)
		{
			for(int i = 0; i < segmentation; ++i)
				yield return Mathf.Lerp(start, end, (float)i / segmentation);
			yield return end;
		}
		#endregion

		#region Quaternion
		public static Quaternion Scale(in this Quaternion quat, float t)
		{
			return Quaternion.SlerpUnclamped(Quaternion.identity, quat, t);
		}
		#endregion

		#region Vector
		/// <param name="range">In [0, 90]</param>
		public static Vector3 RotateEulerWithZenithClamped(this Vector3 eulers, in Vector3 delta, float range = 90f)
		{
			range = Mathf.Clamp(range, 0f, 90f);

			var zenith = Mod(eulers.x, 360);
			if(zenith > 180f)
				zenith -= 360f;
			zenith += delta.x;
			zenith = Mathf.Clamp(zenith, -range, range);
			if(zenith < 0f)
				zenith += 360f;

			eulers += delta;
			eulers.x = zenith;

			return eulers;
		}

		public static Vector3 TransformAroundPivot(in Vector3 v, in Matrix4x4 transform, in Vector3 pivot)
		{
			return transform.MultiplyPoint(v - pivot) + pivot;
		}

		public static Vector3 Average(IEnumerable<Vector3> vectors)
		{
			int i = 0;
			Vector3 sum = default;
			foreach(var v in vectors)
			{
				++i;
				sum += v;
			}
			return sum / i;
		}
		#endregion

		#region 2D
		/// <remarks>
		/// Generated by GPT.
		/// </remarks>
		public static bool IsPointinPolygon(Vector2 p, params Vector2[] poly)
		{
			bool inside = false;
			int n = poly.Length;
			for(int i = 0, j = n - 1; i < n; j = i++)
			{
				Vector2 pi = poly[i];
				Vector2 pj = poly[j];

				bool intersect =
					((pi.y > p.y) != (pj.y > p.y)) &&
					(p.x < (pj.x - pi.x) * (p.y - pi.y) / (pj.y - pi.y + 1e-6f) + pi.x);

				if(intersect)
					inside = !inside;
			}
			return inside;
		}

		/// <remarks>
		/// Copied from <c>UnityEditor.HandleUtility.ProjectPointLine</c>.
		/// </remarks>
		public static Vector3 ProjectPointLine(Vector3 point, Vector3 start, Vector3 end)
		{
			Vector3 rhs = point - start;
			Vector3 vector = end - start;
			float magnitude = vector.magnitude;
			Vector3 vector2 = vector;
			if(magnitude > 1E-06f)
			{
				vector2 /= magnitude;
			}

			float value = Vector3.Dot(vector2, rhs);
			value = Mathf.Clamp(value, 0f, magnitude);
			return start + vector2 * value;
		}

		public static float DistanceToLine(Vector3 point, Vector3 start, Vector3 end)
		{
			return ProjectPointLine(point, start, end).magnitude;
		}

		public static float DistanceToPolygon(Vector2 point, Vector2[] poly)
		{
			if(IsPointinPolygon(point, poly))
				return 0f;
			float min = Mathf.Infinity;
			for(int i = 0; i < poly.Length; ++i)
			{
				Vector2 current = poly[i];
				Vector2 next = poly[(i + 1) % poly.Length];
				float distance = DistanceToLine(point, current, next);
				if(distance < min)
					min = distance;
			}
			return min;
		}
		#endregion

		#region Bezier
		public static float Length(in this Bezier3 bezier)
			=> TToDistance(bezier, 1f);

		public static Vector3 SampleByT(in this Bezier3 bezier, in float t)
		{
			float _t = 1 - t;
			return
				Mathf.Pow(_t, 3) * bezier.anchor0 +
				3 * Mathf.Pow(_t, 2) * t * bezier.cp0 +
				3 * _t * Mathf.Pow(t, 2) * bezier.cp1 +
				Mathf.Pow(t, 3) * bezier.anchor1;
		}

		public static Vector3 SampleByDistance(in this Bezier3 bezier, in float distance)
			=> SampleByT(bezier, DistanceToT(bezier, distance));

		// GPT-gen
		public static float TToDistance(in this Bezier3 bezier, in float t)
		{
			float tt = Mathf.Clamp01(t);
			if(tt <= 0f)
				return 0f;

			// 5-point Gaussâ€“Legendre on [-1, 1]
			const float x0 = 0.0f;
			const float x1 = 0.5384693101056831f;
			const float x2 = 0.9061798459386640f;

			const float w0 = 0.5688888888888889f;
			const float w1 = 0.4786286704993665f;
			const float w2 = 0.2369268850561891f;

			static Vector3 Derivative(in Bezier3 b, float u)
			{
				float omt = 1f - u;
				float omt2 = omt * omt;
				float u2 = u * u;

				// B'(u) = 3(1-u)^2(P1-P0) + 6(1-u)u(P2-P1) + 3u^2(P3-P2)
				return
					(3f * omt2) * (b.cp0 - b.anchor0) +
					(6f * omt * u) * (b.cp1 - b.cp0) +
					(3f * u2) * (b.anchor1 - b.cp1);
			}

			float half = 0.5f * tt;
			float sum = 0f;

			float u0 = half * (x0 + 1f);
			float u1a = half * (-x1 + 1f);
			float u1b = half * (x1 + 1f);
			float u2a = half * (-x2 + 1f);
			float u2b = half * (x2 + 1f);

			sum += w0 * Derivative(bezier, u0).magnitude;
			sum += w1 * (Derivative(bezier, u1a).magnitude + Derivative(bezier, u1b).magnitude);
			sum += w2 * (Derivative(bezier, u2a).magnitude + Derivative(bezier, u2b).magnitude);

			return half * sum;
		}

		// GPT-gen
		public static float DistanceToT(in this Bezier3 bezier, in float distance)
		{
			float total = TToDistance(bezier, 1f);

			if(distance <= 0f)
				return 0f;
			if(distance >= total)
				return 1f;

			float lo = 0f;
			float hi = 1f;
			float mid = 0f;

			for(int i = 0; i < 6; ++i)
			{
				mid = 0.5f * (lo + hi);
				float s = TToDistance(bezier, mid);

				if(s < distance)
					lo = mid;
				else
					hi = mid;
			}

			return mid;
		}
		#endregion
	}
}
